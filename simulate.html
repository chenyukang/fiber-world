<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lightning Network Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000510; /* Ultra Dark Dark */
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle at center, #0f172a 0%, #000000 100%);
        }

        canvas {
            display: block;
        }

        .ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 10;
        }

        .stats-card {
            background: rgba(0, 5, 16, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(56, 189, 248, 0.2);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(56, 189, 248, 0.1);
            min-width: 250px;
        }

        .stat-item {
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            padding-bottom: 4px;
        }

        .stat-item:last-child { border-bottom: none; }

        .stat-label {
            color: #94a3b8;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .stat-value {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 1.1rem;
            color: #38bdf8;
        }

        /* Help Overlay */
        .help-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 5, 16, 0.85);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 12px;
            color: #cbd5e1;
            font-size: 0.9rem;
            z-index: 20;
            max-width: 300px;
            transition: opacity 0.3s;
            pointer-events: none; /* Allow clicking through if needed, or set auto if interactive */
        }

        .help-title {
            color: #fff;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 1rem;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            padding-bottom: 5px;
        }

        .help-item {
            margin-bottom: 6px;
            display: flex;
            align-items: flex-start;
        }

        .help-key {
            font-weight: bold;
            color: #38bdf8;
            margin-right: 8px;
            min-width: 70px;
        }

        .controls {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            pointer-events: auto;
            background: rgba(0, 5, 16, 0.85);
            padding: 12px 25px;
            border-radius: 50px;
            border: 1px solid rgba(56, 189, 248, 0.3);
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(8px);
            align-items: center;
        }

        button {
            background: rgba(56, 189, 248, 0.1);
            color: #38bdf8;
            border: 1px solid rgba(56, 189, 248, 0.4);
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
        }

        button:hover {
            background: rgba(56, 189, 248, 0.3);
            transform: translateY(-2px);
            color: white;
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.3);
        }

        /* Distinct styles for L1 actions */
        button.l1-action {
            border-color: #a855f7; /* Purple for L1 */
            color: #d8b4fe;
            background: rgba(168, 85, 247, 0.1);
        }
        button.l1-action:hover {
            background: rgba(168, 85, 247, 0.3);
            box-shadow: 0 0 15px rgba(168, 85, 247, 0.3);
        }

        /* Distinct styles for L2 Payment actions */
        button.l2-action {
            border-color: #fbbf24; /* Amber/Gold for Payment */
            color: #fcd34d;
            background: rgba(251, 191, 36, 0.1);
        }
        button.l2-action:hover {
            background: rgba(251, 191, 36, 0.3);
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.3);
        }

        /* Distinct styles for Topology actions */
        button.topo-action {
            border-color: #2dd4bf; /* Teal */
            color: #5eead4;
            background: rgba(45, 212, 191, 0.1);
        }
        button.topo-action:hover {
            background: rgba(45, 212, 191, 0.3);
            box-shadow: 0 0 15px rgba(45, 212, 191, 0.3);
        }

        .legend {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            font-size: 0.8rem;
            color: #64748b;
        }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .dot { width: 8px; height: 8px; border-radius: 50%; box-shadow: 0 0 5px currentColor; }

        /* L1 Label */
        .l1-label {
            position: absolute;
            bottom: 10px;
            right: 20px; /* Aligned to the right */
            font-family: 'Courier New', monospace;
            color: #a855f7;
            font-size: 0.9rem;
            opacity: 0.8;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="canvas-container">
        <canvas id="networkCanvas"></canvas>

        <div class="ui-overlay">
            <div class="stats-card">
                <h2 class="text-xl font-bold mb-4 text-white tracking-tight" style="text-shadow: 0 0 10px rgba(255,255,255,0.5);">FIBER NETWORK</h2>

                <!-- Infrastructure -->
                <div class="stat-item">
                    <span class="stat-label">Nodes / Channels</span>
                    <span class="stat-value"><span id="nodeCount">0</span> / <span id="channelCount">0</span></span>
                </div>

                <!-- KEY METRIC: L2 vs L1 Count -->
                <div class="stat-item" style="border-bottom-color: rgba(56, 189, 248, 0.3);">
                    <span class="stat-label text-blue-300">L2 Payments</span>
                    <span class="stat-value" id="l2Count" style="color: #fbbf24; text-shadow: 0 0 8px rgba(251, 191, 36, 0.5);">0</span>
                </div>
                <div class="stat-item" style="border-bottom-color: rgba(168, 85, 247, 0.3);">
                    <span class="stat-label text-purple-300">L1 Txs</span>
                    <span class="stat-value" id="l1Count" style="color: #d8b4fe; text-shadow: 0 0 8px rgba(216, 180, 254, 0.5);">0</span>
                </div>

                <!-- Volume -->
                <div class="stat-item">
                    <span class="stat-label">Volume</span>
                    <span class="stat-value" id="volume">0 CKB</span>
                </div>

            </div>
        </div>

        <!-- Help Overlay -->
        <div id="helpOverlay" class="help-overlay">
            <div class="help-title">Controls</div>
            <div class="help-item">
                <span class="help-key">Click Node</span>
                <span>Select node (Max 2)</span>
            </div>
            <div class="help-item">
                <span class="help-key">Click Line</span>
                <span>Select Channel</span>
            </div>
            <div class="help-item">
                <span class="help-key">Drag</span>
                <span>Move view</span>
            </div>
            <div class="help-item">
                <span class="help-key">Open</span>
                <span>Build Channel for Select Nodes</span>
            </div>
            <div class="help-item">
                <span class="help-key">Close</span>
                <span>Close Selected Channel </span>
            </div>
             <div class="help-item">
                <span class="help-key">Send</span>
                <span>Send Payment (L2)</span>
            </div>
            <div class="mt-2 pt-2 border-t border-gray-700 text-xs text-gray-400">
                Press 'h' to toggle this help.<br>
            </div>
        </div>

        <div class="controls">
            <!-- L1 Actions -->
            <button class="l1-action" id="btnOpenChannel">
                <span>âš¡</span> Open
            </button>
            <button class="l1-action" id="btnCloseChannel">
                <span>ðŸ”’</span> Close
            </button>

            <div style="width: 1px; height: 20px; background: rgba(255,255,255,0.2); margin: 0 2px;"></div>

            <!-- L2 Payment Action -->
            <button class="l2-action" id="btnSendPayment">
                <span>ðŸ’¸</span> Send
            </button>

            <div style="width: 1px; height: 20px; background: rgba(255,255,255,0.2); margin: 0 2px;"></div>

            <!-- Topology Actions -->
            <button class="topo-action" id="btnNewPeer">
                <span>âž•</span> Peer Join
            </button>
            <button class="topo-action" id="btnPeerLeave">
                <span>âž–</span> Peer Leave
            </button>

            <div style="width: 1px; height: 20px; background: rgba(255,255,255,0.2); margin: 0 2px;"></div>

            <!-- Traffic -->
            <button id="btnAddTraffic">
                <span>ðŸŒŠ</span> Surge
            </button>
        </div>

        <div class="l1-label">CKB L1 Network</div>
    </div>

    <script>
        const canvas = document.getElementById('networkCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        // --- HELP TOGGLE ---
        document.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'h') {
                const help = document.getElementById('helpOverlay');
                help.style.opacity = help.style.opacity === '0' ? '1' : '0';
            }
        });

        // --- SCENE TRANSLATION VARIABLES ---
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let wasDragging = false; // Flag to differentiate click from drag
        // ------------------------------------

        // Entities
        let nodes = [];
        let edges = [];
        let packets = [];
        let particles = [];
        let transactions = []; // L1 Transactions
        let blocks = []; // Visual blocks at bottom

        // Statistics
        let totalVolume = 0;
        let tpsCounter = 0;
        let totalL2TxCount = 0;
        let totalL1TxCount = 0;

        // L1 Sequence Counter
        let l1SequenceCounter = 1;

        // Configuration
        const NODE_COUNT = 30; // Initial count
        const MAX_NODES = 50;
        const MIN_NODES = 5;
        const L1_HEIGHT = 60; // Bottom area for blockchain
        // SPEED ADJUSTMENT: Slower speed for better visibility of hops
        const PACKET_SPEED = 0.025;
        const CLICK_TOLERANCE = 10; // Pixels distance to detect line click

        // Node Types Configuration
        const NODE_TYPES = {
            HUB: { id: 'HUB', radius: 10, color: '#c084fc', glowColor: 'rgba(192, 132, 252, 0.6)', prob: 0.15, reach: 350 },
            STD: { id: 'STD', radius: 6, color: '#0ea5e9', glowColor: 'rgba(14, 165, 233, 0.4)', prob: 0.45, reach: 200 },
            LEAF: { id: 'LEAF', radius: 3.5, color: '#2dd4bf', glowColor: 'rgba(45, 212, 191, 0.2)', prob: 1.0, reach: 120 }
        };

        // Edge Colors (Simulating Capacity Types)
        const EDGE_COLORS = [
            'rgba(56, 189, 248, 0.3)', // Default Blue
            'rgba(168, 85, 247, 0.3)', // Purple
            'rgba(45, 212, 191, 0.3)', // Teal
            'rgba(99, 102, 241, 0.3)'  // Indigo
        ];
        const EDGE_COLORS_CORE = [
            'rgba(56, 189, 248, 0.6)',
            'rgba(168, 85, 247, 0.6)',
            'rgba(45, 212, 191, 0.6)',
            'rgba(99, 102, 241, 0.6)'
        ];

        // Interaction
        let selectedNodes = []; // Changed to array for multi-selection
        let selectedEdge = null;
        let mousePos = { x: 0, y: 0 };

        // Global L1 Landing Spot (Screen Coords)
        let L1_LANDING_X;

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;

            // Define L1 landing X position (Screen coordinates: 75% across)
            L1_LANDING_X = width * 0.75;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Classes ---

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 2 + 0.5;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.decay = Math.random() * 0.03 + 0.02;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
            }
            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                // Apply translation offset
                ctx.arc(this.x + offsetX, this.y + offsetY, 1.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class Transaction {
            constructor(type, data) {
                this.type = type; // 'open' or 'close'
                this.data = data; // {nodeA, nodeB} or {edge}
                this.finished = false;

                // Start position (World Coords) - These are fixed
                if (type === 'open') {
                    this.startX = (data.nodeA.x + data.nodeB.x) / 2;
                    this.startY = (data.nodeA.y + data.nodeB.y) / 2;
                } else {
                    this.startX = (data.edge.from.x + data.edge.to.x) / 2;
                    this.startY = (data.edge.from.y + data.edge.to.y) / 2;
                }

                // Target position (Screen Coords) - Fixed L1 spot
                this.targetX = L1_LANDING_X;
                this.targetY = height - L1_HEIGHT/2;

                this.progress = 0;
                this.speed = 0.04;

                // Current position (Screen Coords) - Calculated in update
                this.x = this.startX + offsetX;
                this.y = this.startY + offsetY;
            }

            update() {
                if (this.progress < 1) {
                    this.progress += this.speed;
                    if (this.progress > 1) this.progress = 1;

                    // Calculate current Screen Start Position (due to offset changes)
                    const currentStartX = this.startX + offsetX;
                    const currentStartY = this.startY + offsetY;

                    // Interpolate position from current Screen Start to Target Screen Position
                    this.x = currentStartX + (this.targetX - currentStartX) * this.progress;
                    this.y = currentStartY + (this.targetY - currentStartY) * this.progress;

                } else {
                    this.finished = true;
                    this.execute();
                }
            }

            execute() {
                // Trigger the actual network change
                if (this.type === 'open') {
                    // Create edge
                    addEdge(this.data.nodeA, this.data.nodeB);

                    // Flash effect at the L1 confirmation area (using final screen coords)
                    createExplosion(this.x, this.y, '#0ea5e9');
                } else if (this.type === 'close') {
                    const idx = edges.indexOf(this.data.edge);
                    if (idx > -1) {
                        edges.splice(idx, 1);
                        const { from, to } = this.data.edge;
                        from.connections = from.connections.filter(n => n !== to);
                        to.connections = to.connections.filter(n => n !== from);
                    }

                    // Flash effect at the L1 confirmation area (using final screen coords)
                    createExplosion(this.x, this.y, '#ef4444');
                }

                totalL1TxCount++;

                // Store the sequence number and increment the counter
                const sequence = l1SequenceCounter++;

                // Spawn the block exactly where the TX landed, including sequence number
                blocks.push({
                    x: this.targetX,
                    w: 40,
                    h: 40,
                    color: this.type === 'open' ? '#0ea5e9' : '#ef4444',
                    sequence: sequence // Store sequence number
                });
            }

            draw() {
                // Draw a box representing the TX
                const drawX = this.x; // Already screen coords
                const drawY = this.y;

                ctx.fillStyle = '#a855f7'; // Purple for L1 interactions
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#a855f7';
                ctx.fillRect(drawX - 6, drawY - 6, 12, 12);

                // Label
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#fff';
                ctx.font = '10px Arial';
                ctx.fillText(this.type === 'open' ? 'FUND' : 'SETTLE', drawX + 10, drawY);

                // Draw trailing line back to source (connects TX to the node midpoint)
                ctx.beginPath();
                ctx.moveTo(drawX, drawY);
                const startXScreen = this.startX + offsetX;
                const startYScreen = this.startY + offsetY;
                ctx.lineTo(startXScreen, startYScreen);

                ctx.strokeStyle = 'rgba(168, 85, 247, 0.3)';
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        class Node {
            constructor(id, x, y) {
                this.id = id;
                this.x = x;
                this.y = y;

                // Determine Type
                const rand = Math.random();
                if (rand < NODE_TYPES.HUB.prob) this.type = NODE_TYPES.HUB;
                else if (rand < NODE_TYPES.HUB.prob + NODE_TYPES.STD.prob) this.type = NODE_TYPES.STD;
                else this.type = NODE_TYPES.LEAF;

                this.pulse = 0;
                this.connections = [];
                this.errorPulse = 0; // New: For visual feedback on failure
            }

            update() {
                if (this.pulse > 0) this.pulse -= 0.05;
                if (this.pulse < 0) this.pulse = 0;

                if (this.errorPulse > 0) this.errorPulse -= 0.05;
                if (this.errorPulse < 0) this.errorPulse = 0;
            }

            draw() {
                const isSelected = selectedNodes.includes(this);
                const drawX = this.x + offsetX;
                const drawY = this.y + offsetY;

                let color = isSelected ? '#fbbf24' : this.type.color;
                let glowColor = isSelected ? '#fbbf24' : this.type.glowColor;

                // Error state overrides
                if (this.errorPulse > 0) {
                    color = '#ef4444';
                    glowColor = 'rgba(239, 68, 68, 0.8)';
                }

                const radius = this.type.radius;

                // Glow / Pulse
                // Highlight red bold if selected
                if (this.pulse > 0 || this.errorPulse > 0 || isSelected || this.type.id === 'HUB') {
                    let glowStrength = isSelected ? 40 : (this.type.id === 'HUB' ? 20 : 15);
                    let glowAlpha = isSelected ? 0.8 : (this.type.id === 'HUB' ? 0.3 : this.pulse * 0.5);

                    if(this.errorPulse > 0) {
                        glowStrength = 40;
                        glowAlpha = this.errorPulse;
                    }

                    ctx.shadowBlur = glowStrength;
                    ctx.shadowColor = isSelected ? '#ef4444' : glowColor; // Red if selected

                    ctx.beginPath();
                    // Increased radius for selected
                    const r = isSelected ? radius + 4 : radius + (this.pulse * 8) + (this.errorPulse * 5);
                    ctx.arc(drawX, drawY, r, 0, Math.PI * 2);

                    if (this.errorPulse > 0) {
                         ctx.fillStyle = `rgba(239, 68, 68, ${glowAlpha})`;
                    } else if (isSelected) {
                         ctx.fillStyle = `rgba(239, 68, 68, ${glowAlpha})`; // Red Bold
                    } else if (this.type.id === 'HUB') {
                         ctx.fillStyle = this.type.glowColor;
                    } else {
                         ctx.fillStyle = `rgba(14, 165, 233, ${glowAlpha})`;
                    }

                    ctx.fill();
                }

                // Core of selected node
                if (isSelected) {
                    ctx.beginPath();
                    ctx.arc(drawX, drawY, radius + 2, 0, Math.PI * 2);
                    ctx.fillStyle = '#fff';
                    ctx.fill();
                } else if (!this.pulse && !this.errorPulse && this.type.id !== 'HUB') {
                    // Normal draw for unselected, idle nodes
                    ctx.beginPath();
                    ctx.arc(drawX, drawY, radius, 0, Math.PI * 2);
                    ctx.fillStyle = color;
                    ctx.fill();
                } else {
                    // Already drawn core in glow block for others or standard overlay
                    // Just ensure core exists for Hubs if not selected
                    if(this.type.id === 'HUB' && !isSelected && !this.errorPulse) {
                        ctx.beginPath();
                        ctx.arc(drawX, drawY, radius, 0, Math.PI * 2);
                        ctx.fillStyle = '#fff'; // Hub core
                        ctx.fill();
                    }
                }

                ctx.shadowBlur = 0;
            }
        }

        class Packet {
            constructor(path) {
                this.path = path;
                this.currentIndex = 0;
                this.progress = 0;
                this.speed = PACKET_SPEED + (Math.random() * 0.01);
                this.finished = false;
                this.trail = [];
                this.amount = Math.floor(Math.random() * 500) * 10 + 100;
            }

            update() {
                this.progress += this.speed;
                const startNode = this.path[this.currentIndex];
                const endNode = this.path[this.currentIndex + 1];

                if (!startNode || !endNode || !areConnected(startNode, endNode)) {
                    this.finished = true;
                    return;
                }

                const currentX = startNode.x + (endNode.x - startNode.x) * this.progress;
                const currentY = startNode.y + (endNode.y - startNode.y) * this.progress;

                this.trail.push({x: currentX, y: currentY, age: 1.0});
                for(let t of this.trail) t.age -= 0.05;
                this.trail = this.trail.filter(t => t.age > 0);

                if (this.progress >= 1) {
                    this.progress = 0;
                    this.currentIndex++;
                    this.path[this.currentIndex].pulse = 1.0;

                    // Use translated coordinates for explosion
                    createExplosion(endNode.x + offsetX, endNode.y + offsetY, '#fbbf24');

                    if (this.currentIndex >= this.path.length - 1) {
                        this.finished = true;
                        totalL2TxCount++;
                        totalVolume += this.amount;
                    }
                }
            }

            draw() {
                if (this.finished || this.trail.length === 0) return;

                // Apply translation to all trail points
                ctx.beginPath();
                ctx.moveTo(this.trail[0].x + offsetX, this.trail[0].y + offsetY);
                for (let i = 1; i < this.trail.length; i++) ctx.lineTo(this.trail[i].x + offsetX, this.trail[i].y + offsetY);

                ctx.lineCap = 'round';
                ctx.lineWidth = 3;
                ctx.strokeStyle = `rgba(251, 191, 36, 0.8)`;
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#fbbf24';
                ctx.stroke();
                ctx.shadowBlur = 0;

                // Head
                const head = this.trail[this.trail.length-1];
                const headX = head.x + offsetX;
                const headY = head.y + offsetY;

                ctx.beginPath();
                ctx.arc(headX, headY, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();

                // Draw Amount Text
                ctx.font = "bold 11px sans-serif";
                ctx.fillStyle = "#fbbf24";
                ctx.textAlign = "center";
                ctx.shadowColor = "rgba(0,0,0,0.8)";
                ctx.shadowBlur = 4;
                ctx.fillText(this.amount + "", headX, headY - 10);
                ctx.shadowBlur = 0;
            }
        }

        // --- Helpers ---

        // Helper to check if point q lies on segment pr
        function onSegment(p, q, r) {
            return (q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) &&
                    q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y));
        }

        // Utility function to find orientation of ordered triplet (p, q, r).
        function orientation(p, q, r) {
            const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
            if (val === 0) return 0; // collinear
            return (val > 0) ? 1 : 2; // clockwise or counterclockwise
        }

        // Helper to check if line segment (p1, q1) intersects with line segment (p2, q2)
        function doLinesIntersect(p1, q1, p2, q2) {
            // Find the four orientations needed for general and special cases
            const o1 = orientation(p1, q1, p2);
            const o2 = orientation(p1, q1, q2);
            const o3 = orientation(p2, q2, p1);
            const o4 = orientation(p2, q2, q1);

            // General case
            if (o1 !== 0 && o2 !== 0 && o3 !== 0 && o4 !== 0 && o1 !== o2 && o3 !== o4) {
                return true;
            }

            // Special Cases: Check for collinearity and segment overlap
            if (o1 === 0 && onSegment(p1, p2, q1)) return true;
            if (o2 === 0 && onSegment(p1, q2, q1)) return true;
            if (o3 === 0 && onSegment(p2, p1, q2)) return true;
            if (o4 === 0 && onSegment(p2, q1, q2)) return true;

            return false; // Doesn't intersect
        }

        // Check if a potential new edge (n1, n2) intersects any existing edge
        function intersectsExistingEdge(n1, n2) {
            for(let existingEdge of edges) {
                const eFrom = existingEdge.from;
                const eTo = existingEdge.to;

                // Exclude edges sharing endpoints with the new edge (n1, n2)
                if (n1 === eFrom || n1 === eTo || n2 === eFrom || n2 === eTo) {
                    continue;
                }

                if (doLinesIntersect(n1, n2, eFrom, eTo)) {
                    return true;
                }
            }
            return false;
        }

        // NOTE: createExplosion is updated to take screen coordinates, not world coordinates.
        function createExplosion(x, y, color) {
            for(let k=0; k<8; k++) particles.push(new Particle(x - offsetX, y - offsetY, color));
        }

        function formatCapacity(cap) {
            if (cap >= 1000000) return (cap / 1000000).toFixed(1) + "M";
            if (cap >= 1000) return (cap / 1000).toFixed(0) + "K";
            return cap;
        }

        // Distance from point p to line segment vw
        function distToSegment(p, v, w) {
            const l2 = (v.x - w.x) ** 2 + (v.y - w.y) ** 2;
            if (l2 === 0) return Math.hypot(p.x - v.x, p.y - v.y);
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            const projX = v.x + t * (w.x - v.x);
            const projY = v.y + t * (w.y - v.y);
            return Math.hypot(p.x - projX, p.y - projY);
        }

        function initNetwork() {
            nodes = [];
            edges = [];
            packets = [];
            particles = [];
            transactions = [];
            blocks = [];
            selectedNodes = [];
            selectedEdge = null;
            l1SequenceCounter = 1; // Reset counter on init

            totalL2TxCount = 0;
            totalL1TxCount = 0;
            totalVolume = 0;

            const numNodes = NODE_COUNT;
            const halfNodes = Math.ceil(numNodes / 2);

            // Define two separate areas based on screen width
            const margin = 100;
            const separationWidth = 50;
            const networkWidth = (width / 2) - margin - (separationWidth / 2);
            const networkHeight = height - L1_HEIGHT - (margin * 2);

            let nodesLeft = [];
            let nodesRight = [];

            // --- Network 1: Left ---
            for (let i = 0; i < halfNodes; i++) {
                // X position confined to the left half
                const x = Math.random() * networkWidth + margin;
                const y = Math.random() * networkHeight + margin;
                const newNode = new Node(Date.now() + Math.random() + i, x, y);
                nodes.push(newNode);
                nodesLeft.push(newNode);
            }

            // --- Network 2: Right ---
            for (let i = 0; i < numNodes - halfNodes; i++) {
                // X position confined to the right half
                const x = Math.random() * networkWidth + (width / 2) + (separationWidth / 2);
                const y = Math.random() * networkHeight + margin;
                const newNode = new Node(Date.now() + Math.random() + i + halfNodes, x, y);
                nodes.push(newNode);
                nodesRight.push(newNode);
            }

            // Connect nodes within their own clusters
            connectClusters(nodesLeft);
            connectClusters(nodesRight);
        }

        // Helper function to connect nodes within a list (WITH GUARANTEED CONNECTIVITY and intersection check)
        function connectClusters(clusterNodes) {
             if (clusterNodes.length < 2) return;

             // 1. Probabilistic connection (for initial spread) - Check intersection
             clusterNodes.forEach(n1 => {
                clusterNodes.forEach(n2 => {
                    if (n1 === n2 || areConnected(n1, n2)) return;

                    const dist = Math.hypot(n1.x - n2.x, n1.y - n2.y);
                    const reachLimit = (n1.type.reach + n2.type.reach) / 1.8;

                    // Connect if close and randomly successful AND does NOT intersect
                    if (dist < reachLimit && Math.random() > 0.7 && !intersectsExistingEdge(n1, n2)) {
                         addEdge(n1, n2);
                    }
                });
             });

             // 2. GUARANTEED CONNECTIVITY: Prim's algorithm inspired to ensure single graph
             let visited = new Set();
             let startNode = clusterNodes[0];
             visited.add(startNode);

             while (visited.size < clusterNodes.length) {
                 let closestEdge = null;
                 let minD = Infinity;
                 let connectNodeA = null; // A is always in visited
                 let connectNodeB = null; // B is always NOT in visited

                 // Find the shortest edge connecting a visited node (A) to an unvisited node (B)
                 for (let nodeA of visited) {
                     for (let nodeB of clusterNodes) {
                         if (!visited.has(nodeB)) {
                             const dist = Math.hypot(nodeA.x - nodeB.x, nodeA.y - nodeB.y);
                             if (dist < minD) {
                                 minD = dist;
                                 connectNodeA = nodeA;
                                 connectNodeB = nodeB;
                             }
                         }
                     }
                 }

                 // If we found a valid new node to connect
                 if (connectNodeB) {
                     // Check if already connected by random connection step. If not, force connect.
                     if (!areConnected(connectNodeA, connectNodeB)) {
                         // Must check intersection for the guaranteed connection path
                         if (!intersectsExistingEdge(connectNodeA, connectNodeB)) {
                            addEdge(connectNodeA, connectNodeB);
                         }
                         // If it intersects, we skip this connection and try again with the next shortest edge from the visited set,
                         // although this simplified Prim's might get stuck if all paths intersect. For visual demo, this is OK.
                     }
                     visited.add(connectNodeB);
                 } else {
                    // Safety break if the algorithm fails to find new connection
                    break;
                 }
             }
        }

        // This function is still needed for Peer Join
        function createInitialNode() {
            // Generate nodes within original bounds
            const x = Math.random() * (width - 100) + 50;
            const y = Math.random() * (height - L1_HEIGHT - 100) + 50;
            const newNode = new Node(Date.now() + Math.random(), x, y);
            nodes.push(newNode);
        }

        // Removed reconnectAll as it is replaced by initNetwork logic

        function addNode() {
            const x = Math.random() * (width - 100) + 50;
            const y = Math.random() * (height - L1_HEIGHT - 100) + 50;
            const newNode = new Node(Date.now() + Math.random(), x, y);
            newNode.pulse = 1.0;
            nodes.push(newNode);

            let closest = null;
            let minD = Infinity;

            for (let other of nodes) {
                if (other === newNode) continue;
                const dist = Math.hypot(newNode.x - other.x, newNode.y - other.y);
                if (dist < minD) {
                    minD = dist;
                    closest = other;
                }
            }

            // Check intersection before starting TX for join
            if (closest && !intersectsExistingEdge(newNode, closest)) {
                transactions.push(new Transaction('open', {nodeA: newNode, nodeB: closest}));
            } else if (closest) {
                // If it intersects, just pulse the node but don't add the edge (fail silently)
                newNode.errorPulse = 0.5;
            }
        }

        function removeNode() {
            if (nodes.length <= MIN_NODES) return;

            let idx = Math.floor(Math.random() * nodes.length);
            let node = nodes[idx];

            if (selectedNodes.includes(node)) return;

            const connectedEdges = edges.filter(e => e.from === node || e.to === node);

            connectedEdges.forEach(e => {
                transactions.push(new Transaction('close', {edge: e}));
            });

            createExplosion(node.x + offsetX, node.y + offsetY, '#ef4444');

            nodes.splice(idx, 1);

            for(let e of connectedEdges) {
                if (e === selectedEdge) selectedEdge = null;
                const eIdx = edges.indexOf(e);
                if(eIdx > -1) edges.splice(eIdx, 1);

                const { from, to } = e;
                if(from !== node) from.connections = from.connections.filter(c => c !== node);
                if(to !== node) to.connections = to.connections.filter(c => c !== node);
            }
        }

        function areConnected(a, b) {
            if(!a || !b) return false;
            // Check both directions
            return a.connections.includes(b) && b.connections.includes(a);
        }

        // Helper to find edge object between two nodes
        function findEdge(a, b) {
             return edges.find(e =>
                (e.from === a && e.to === b) || (e.from === b && e.to === a)
            );
        }

        function addEdge(a, b) {
            if (areConnected(a, b)) return;
            const colorIdx = Math.floor(Math.random() * EDGE_COLORS.length);
            const capacity = Math.floor(Math.random() * 4500000) + 500000;
            edges.push({ from: a, to: b, colorIdx: colorIdx, capacity: capacity });
            a.connections.push(b);
            b.connections.push(a);
        }

        function findPath(start, end) {
            let queue = [[start]];
            let visited = new Set([start]);
            let predecessors = new Map(); // Keep track of path

            while (queue.length > 0) {
                let path = queue.shift();
                let node = path[path.length - 1];

                if (node === end) return path;

                // Sort neighbors by type to prefer Hubs? Or just standard BFS
                // Standard BFS gives shortest path by hops
                for (let neighbor of node.connections) {
                    if (!visited.has(neighbor)) {
                        visited.add(neighbor);
                        queue.push([...path, neighbor]);
                    }
                }
            }
            return null;
        }

        function triggerRandomPayment() {
            if (nodes.length < 2) return;
            const start = nodes[Math.floor(Math.random() * nodes.length)];
            let end = nodes[Math.floor(Math.random() * nodes.length)];
            let tries = 0;
            while ((end === start || !start || !end) && tries < 10) {
                end = nodes[Math.floor(Math.random() * nodes.length)];
                tries++;
            }
            if(start && end && start !== end) {
                const path = findPath(start, end);
                if (path && path.length > 1) packets.push(new Packet(path));
                // If no path is found, it just silently fails, which is correct for partitioned networks
            }
        }

        // --- L1 Logic ---

        function handleOpenChannel() {
            const [a, b] = selectedNodes;

            // --- Logic 1: Handle Manual Selection (2 Nodes) ---
            if (selectedNodes.length === 2) {
                if (areConnected(a, b)) {
                    // Already connected: Flash and trigger a payment demo
                    createExplosion((a.x+b.x)/2 + offsetX, (a.y+b.y)/2 + offsetY, '#fbbf24');
                    const path = findPath(a, b);
                    if(path) packets.push(new Packet(path));
                } else if (!intersectsExistingEdge(a, b)) { // New Intersection Check
                    // Not connected and doesn't intersect: Initiate funding transaction
                    transactions.push(new Transaction('open', {nodeA: a, nodeB: b}));
                } else {
                    // Intersects
                    a.errorPulse = 1.0;
                    b.errorPulse = 1.0;
                }
                return;
            }

            // --- Logic 2: Handle Random Fallback (0 or 1 Node Selected) ---

            let attempts = 0;
            // Use a higher attempt limit to ensure we find a valid pair
            while(attempts < 100) {
                // 1. Pick a random node (rA)
                const rA = nodes[Math.floor(Math.random() * nodes.length)];
                if (!rA) { attempts++; continue; }

                let closestUnconnected = null;
                let minD = Infinity;

                // 2. Find the closest *unconnected* node (rB)
                for (const rB of nodes) {
                    if (rA === rB || areConnected(rA, rB)) continue;

                    const dist = Math.hypot(rA.x - rB.x, rA.y - rB.y);
                    const reachLimit = (rA.type.reach + rB.type.reach) / 1.8;

                    // Check distance AND reach limit, and ensure it's the minimum distance found so far
                    if (dist < minD && dist < reachLimit) {
                        // Check intersection only if it's the current minimum distance candidate
                        if (!intersectsExistingEdge(rA, rB)) {
                            minD = dist;
                            closestUnconnected = rB;
                        }
                    }
                }

                if (closestUnconnected) {
                    transactions.push(new Transaction('open', {nodeA: rA, nodeB: closestUnconnected}));
                    return; // Success, exit function
                }
                attempts++;
            }

            // If still failed (e.g. islands are far), FORCE a random connection
            let forceAttempts = 0;
            while(forceAttempts < 20) {
                 const rA = nodes[Math.floor(Math.random() * nodes.length)];
                 const rB = nodes[Math.floor(Math.random() * nodes.length)];
                 if(rA !== rB && !areConnected(rA, rB) && !intersectsExistingEdge(rA, rB)) { // Check intersection for forced
                      transactions.push(new Transaction('open', {nodeA: rA, nodeB: rB}));
                      return;
                 }
                 forceAttempts++;
            }
        }

        function handleCloseChannel() {
            // --- Logic 1: Handle Selected Edge ---
            if (selectedEdge) {
                transactions.push(new Transaction('close', {edge: selectedEdge}));
                selectedEdge = null;
                return;
            }

            // --- Logic 2: Handle Random Fallback (No Edge Selected) ---
            if (edges.length === 0) return;

            // Randomly select one edge to close
            const edge = edges[Math.floor(Math.random() * edges.length)];
            transactions.push(new Transaction('close', {edge: edge}));
        }

        function handleSendPayment() {
            if (selectedNodes.length !== 2) {
                // Shake button? For now just return or maybe flash a toast
                return;
            }
            const [start, end] = selectedNodes;
            const path = findPath(start, end);

            if (path && path.length > 1) {
                // Highlight path
                for (let i = 0; i < path.length - 1; i++) {
                    const u = path[i];
                    const v = path[i+1];
                    const edge = findEdge(u, v);
                    if(edge) edge.flash = 1.0; // We'll use this in draw
                }

                // Send burst
                for(let i=0; i<5; i++) {
                    setTimeout(() => packets.push(new Packet(path)), i * 200);
                }
            } else {
                // Fail
                start.errorPulse = 1.0;
                end.errorPulse = 1.0;
            }
        }

        // --- Main Loop ---

        function animate() {
            ctx.clearRect(0, 0, width, height);

            // 1. Draw Blockchain Area (NOT translated)
            ctx.fillStyle = 'rgba(15, 23, 42, 0.8)';
            ctx.fillRect(0, height - L1_HEIGHT, width, L1_HEIGHT);
            ctx.strokeStyle = 'rgba(168, 85, 247, 0.3)';
            ctx.beginPath();
            ctx.moveTo(0, height - L1_HEIGHT);
            ctx.lineTo(width, height - L1_HEIGHT);
            ctx.stroke();

            // Draw Blocks moving
            for(let i = blocks.length - 1; i >= 0; i--) {
                let b = blocks[i];
                b.x -= 1; // scroll left

                ctx.fillStyle = b.color;
                ctx.globalAlpha = 0.6;
                ctx.fillRect(b.x, height - L1_HEIGHT + 10, b.w, b.h);
                ctx.globalAlpha = 1.0;
                ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                ctx.strokeRect(b.x, height - L1_HEIGHT + 10, b.w, b.h);

                // Draw sequence number
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`#${b.sequence}`, b.x + b.w / 2, height - L1_HEIGHT + 10 + b.h / 2 + 3);

                if(b.x < -50) blocks.splice(i, 1);
            }

            // 2. Draw Edges (Colored)
            ctx.lineWidth = 3;
            for (let edge of edges) {
                const fromX = edge.from.x + offsetX;
                const fromY = edge.from.y + offsetY;
                const toX = edge.to.x + offsetX;
                const toY = edge.to.y + offsetY;

                ctx.beginPath();
                ctx.moveTo(fromX, fromY);
                ctx.lineTo(toX, toY);
                const color = EDGE_COLORS[edge.colorIdx] || EDGE_COLORS[0];
                const grad = ctx.createLinearGradient(fromX, fromY, toX, toY);

                if (edge === selectedEdge || edge.flash > 0) {
                    grad.addColorStop(0, '#ffffff');
                    grad.addColorStop(0.5, '#ffffff');
                    grad.addColorStop(1, '#ffffff');
                    ctx.shadowColor = '#ffffff';
                    ctx.shadowBlur = 15;
                    if(edge.flash > 0) edge.flash -= 0.05;
                } else {
                    grad.addColorStop(0, color);
                    grad.addColorStop(0.5, color.replace('0.3', '0.5'));
                    grad.addColorStop(1, color);
                    ctx.shadowBlur = 0;
                }

                ctx.strokeStyle = grad;
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            // Core & Text
            ctx.lineWidth = 1;
            ctx.font = "10px sans-serif";
            ctx.textAlign = "center";
            for (let edge of edges) {
                const isSelected = (edge === selectedEdge || edge.flash > 0);
                const fromX = edge.from.x + offsetX;
                const fromY = edge.from.y + offsetY;
                const toX = edge.to.x + offsetX;
                const toY = edge.to.y + offsetY;

                ctx.beginPath();
                ctx.moveTo(fromX, fromY);
                ctx.lineTo(toX, toY);

                const color = EDGE_COLORS_CORE[edge.colorIdx] || EDGE_COLORS_CORE[0];
                ctx.strokeStyle = isSelected ? '#ffffff' : color;
                ctx.stroke();

                const midX = (fromX + toX) / 2;
                const midY = (fromY + toY) / 2;
                ctx.fillStyle = isSelected ? "#ffffff" : "rgba(148, 163, 184, 0.7)";
                ctx.fillText(formatCapacity(edge.capacity), midX, midY - 5);
            }

            // 3. Transactions
            for (let i = transactions.length - 1; i >= 0; i--) {
                transactions[i].update();
                transactions[i].draw();
                if (transactions[i].finished) transactions.splice(i, 1);
            }

            // 4. Packets
            for (let i = packets.length - 1; i >= 0; i--) {
                packets[i].update();
                packets[i].draw();
                if (packets[i].finished) packets.splice(i, 1);
            }

            // 5. Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].draw();
                if (particles[i].life <= 0) particles.splice(i, 1);
            }

            // 6. Nodes
            for (let node of nodes) {
                node.update();
                node.draw();
            }

            // UI: Selected Node Lines (Optional visual guide) removed per request

            // Update stats
            document.getElementById('nodeCount').innerText = nodes.length;
            document.getElementById('channelCount').innerText = edges.length;
            document.getElementById('l2Count').innerText = totalL2TxCount.toLocaleString();
            document.getElementById('l1Count').innerText = totalL1TxCount.toLocaleString();

            requestAnimationFrame(animate);
        }

        setInterval(() => { if (Math.random() > 0.4) triggerRandomPayment(); }, 400);
        setInterval(() => {
            document.getElementById('volume').innerText = totalVolume.toLocaleString() + " CKB";
        }, 500);

        // --- Dragging / Panning Logic ---

        canvas.addEventListener('mousedown', (e) => {
            // Only respond to left click (button 0)
            if (e.button !== 0) return;

            isDragging = true;
            wasDragging = false; // Reset drag flag
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;

            // Prevent text selection during drag
            e.preventDefault();
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            // Store mouse screen position for UI line drawing
            mousePos.x = e.clientX - rect.left;
            mousePos.y = e.clientY - rect.top;

            if (isDragging) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;

                // Move scene offset
                offsetX += dx;
                offsetY += dy;

                // Check if motion was significant enough to be considered a drag
                if (Math.abs(dx) > 1 || Math.abs(dy) > 1) {
                    wasDragging = true;
                }

                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                document.body.style.cursor = 'grabbing';
            } else {
                // Non-dragging mouse move logic for cursor change
                let hovering = false;
                // Calculate compensated mouse position (World Coordinates)
                const mouseWorldX = mousePos.x - offsetX;
                const mouseWorldY = mousePos.y - offsetY;

                // Check nodes
                for(let n of nodes) {
                    if(Math.hypot(n.x - mouseWorldX, n.y - mouseWorldY) < n.type.radius + 5) {
                        hovering = true; break;
                    }
                }
                // Check edges
                if(!hovering) {
                    for(let e of edges) {
                        if(distToSegment({x: mouseWorldX, y: mouseWorldY}, e.from, e.to) < CLICK_TOLERANCE) {
                            hovering = true; break;
                        }
                    }
                }
                document.body.style.cursor = hovering ? 'pointer' : 'default';
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            isDragging = false;
            document.body.style.cursor = 'default';
        });

        canvas.addEventListener('click', (e) => {
            // Ignore click if it was actually a drag motion
            if (wasDragging) {
                wasDragging = false;
                return;
            }

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Compensate for scene translation to get World Coordinates
            const worldX = x - offsetX;
            const worldY = y - offsetY;

            // Ignore clicks on L1 area (based on screen Y coordinate)
            if(y > height - L1_HEIGHT) return;

            let clickedNode = null;
            let clickedEdge = null;

            // 1. Check Node Clicks
            for (let n of nodes) {
                // Use world coordinates for hit test
                if (Math.hypot(n.x - worldX, n.y - worldY) < n.type.radius + 5) {
                    clickedNode = n;
                    break;
                }
            }

            if (clickedNode) {
                selectedEdge = null; // Clear edge selection

                // Toggle selection logic
                const idx = selectedNodes.indexOf(clickedNode);
                if (idx > -1) {
                    selectedNodes.splice(idx, 1);
                } else {
                    selectedNodes.push(clickedNode);
                    if (selectedNodes.length > 2) selectedNodes.shift();

                    clickedNode.pulse = 1;
                }
                return;
            }

            // 2. Check Edge Clicks
            for (let e of edges) {
                // Use world coordinates for hit test
                if(distToSegment({x: worldX, y: worldY}, e.from, e.to) < CLICK_TOLERANCE) {
                    clickedEdge = e;
                    break;
                }
            }

            if (clickedEdge) {
                selectedEdge = clickedEdge;
                selectedNodes = []; // Clear node selection
            } else {
                // Clicked empty space
                selectedNodes = [];
                selectedEdge = null;
            }
        });

        document.getElementById('btnOpenChannel').addEventListener('click', handleOpenChannel);
        document.getElementById('btnCloseChannel').addEventListener('click', handleCloseChannel);
        document.getElementById('btnSendPayment').addEventListener('click', handleSendPayment);
        document.getElementById('btnNewPeer').addEventListener('click', addNode);
        document.getElementById('btnPeerLeave').addEventListener('click', removeNode);
        document.getElementById('btnAddTraffic').addEventListener('click', () => {
            for(let i=0; i<15; i++) triggerRandomPayment();
        });

        initNetwork();
        animate();
    </script>
</body>
</html>